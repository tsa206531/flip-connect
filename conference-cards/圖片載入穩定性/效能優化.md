# 圖片載入穩定性 / 效能優化

本文檔紀錄本次針對「移動游標導致頻繁重繪與圖片重載」的問題分析、優化策略與變更結果。

---

## 問題現象
- 在首頁移動滑鼠時，Console 出現大量「Rendering cards」日誌，Network 顯示同一張圖片似乎被重複請求。
- 在滾動載入（Infinite Scroll）時，Console 也會連續印出相同數字的「Rendering cards: X」，接著才升到下一個數字（例如 7 → 多次 7 → 11 → 多次 11 → 15）。

## 根因分析
1) 游標光圈使用 React State 追蹤位置
   - `app/page.tsx` 使用 `setState`（mousePosition、isMouseMoving）在 `onMouseMove` 中每次更新，導致 Page re-render。
   - Page re-render 會牽連子樹（包含 CardGrid）一起 re-render，造成「Rendering cards」頻繁印出。

2) 卡片內跟手光圈也以 State 追蹤
   - `components/interactive-card.tsx` 在 `onMouseMove` 中 `setState` 追蹤 hover 光圈位置，每移動一次就 re-render 該卡片。
   - 疊加 1) 的 re-render，更會讓整體卡頓感放大。

3) 圖片 URL 在載入早期不穩定
   - `components/optimized-image.tsx` 中 Cloudinary URL（`transformedSrc`）會依據容器寬度計算。初始 render 可能還未量到寬度（fallback 使用 maxWidth），後續量到寬度後又改變一次 URL。
   - URL 改變可能導致瀏覽器/Next 重新請求圖片，看起來像是「重複載入」。

4) 載入更多造成多次渲染
   - `loadMoreCards` 內部有多次 `setState`（loadingMore、displayedCards、hasMore、nextCursor），即使在 React 18 batching 下，仍可能拆成多次 render 週期。
   - Framer Motion 的動畫初始化（AnimatePresence/進入動畫）也會引發額外的 render 週期。
   - Dev/StrictMode 在開發環境中會額外觸發一些流程，使 render 次數在開發模式下看起來更多。生產模式則較少。

---

## 優化方案與變更

### A. 首頁（/）游標光圈使用 Motion Values（取代 React State）
- 檔案：`app/page.tsx`
- 作法：以 `useMotionValue` + `useSpring` + `useTransform` 驅動光圈位置與透明度，`onMouseMove` 直接 `motionValue.set(...)`，不再使用 `setState`。
- 效果：移動滑鼠時不再造成 Page re-render，因此不會連動 CardGrid re-render；Console 中「Rendering cards」不再因滑鼠移動而狂刷，Network 也不因重繪而重載圖片。

### B. CardGrid 使用 React.memo 防止不必要的 re-render
- 檔案：`components/card-grid.tsx`
- 作法：將 `CardGrid` 以 `memo(CardGrid)` 匯出；當父層 re-render 但 props 未變時，CardGrid 不會重渲染。
- 效果：父層細微狀態變更（如游標）不會再波及卡片網格。

### C. InteractiveCard（卡片內）跟手光圈使用 Motion Values
- 檔案：`components/interactive-card.tsx`
- 作法：
  - 移除 `mousePosition` state；新增 `glowX/glowY` motion values 與 spring 平滑。
  - `onMouseMove` 直接 `glowX/glowY.set(...)`；跟手光圈的 `style` 綁定 motion values。
- 效果：hover 時不因滑鼠移動造成 re-render，效能更平穩。

### D. OptimizedImage 圖片 URL 穩定化
- 檔案：`components/optimized-image.tsx`
- 作法：
  - 使用 `ResizeObserver` 量測容器寬度（`fill` 模式），存於 `measuredWidth`。
  - 首次成功載入後，將量測到的寬度鎖定為 `lockedWidth`，避免後續 URL 抖動。
  - 使用 `useMemo` 計算 `effectiveWidth` 與 `transformedSrc`，僅在依賴變動時更新。
  - 對非 `fill` 模式，若未提供 `width`，以 `width || effectiveWidth` 傳入 `next/image`。
  - 在 `imageProps` 加上 `key: transformedSrc`，確保 React 僅在 URL 真正變化時更新。
- 效果：Cloudinary URL 穩定；避免因初期與後期寬度不同導致的重新請求，減少 Network 重複抓圖。

### E. /draw 頁面的游標光圈也改為 Motion Values
- 檔案：`app/draw/page.tsx`
- 作法：比照首頁，以 motion values 取代游標追蹤 state，`onMouseMove` 直接更新 motion values，並支援 `onMouseLeave` 與 `onTouchMove`。
- 效果：移動游標時不再造成頁面 re-render；互動更順暢。

---

## 變更檔案清單
- `app/page.tsx`（A）
- `components/card-grid.tsx`（B）
- `components/interactive-card.tsx`（C）
- `components/optimized-image.tsx`（D）
- `app/draw/page.tsx`（E）

---

## 驗證與結果
1) Console（Rendering cards）
   - 移動滑鼠時，首頁不再因游標移動而出現大量「Rendering cards」。
   - 滾動載入時，仍可能在每個載入階段看到數次相同數字的「Rendering cards」，主要因為多個 state 更新與動畫初始化；屬正常行為，生產模式會更少。

2) Network（圖片請求）
   - 游標移動不再觸發圖片重新請求。
   - 因 `OptimizedImage` 的寬度鎖定與 `transformedSrc` 穩定化，滾動載入過程不會出現同圖多次下載的抖動現象。

3) 使用體感
   - 滑鼠 hover 與跟手光圈更流暢；滾動載入時不卡頓。

---

## 後續可選強化
- 合併 loadMoreCards 內多個 setState（或以 useReducer 管理）以降低渲染次數。
- 將渲染日誌從 render 移到 `useEffect`（僅在 `displayedCards.length` 改變時印一次）。
- 更進一步的列表虛擬化（如 react-virtual）以應付極大量卡片的場景。
- 對 Cloudinary URL 的 transform 合併策略再加強（仍保留擴充空間）。

---

## 注意事項
- Dev/StrictMode 下的渲染次數會多於生產環境，屬於預期行為。
- 若仍觀察到少數圖片重載，請先確認：
  - 是否確實鎖定了 `lockedWidth`（首次載入時機）。
  - 是否在非 fill 模式下提供了穩定的 `width/height`。
  - 是否有其他上層 state 變更導致 `src` 或 `sizes` 實際變化。

---

## 附註
- 本次優化專注於「互動導致的重繪」與「圖片 URL 抖動」兩大面向；在不影響現有 UI/動畫的前提下，降低 re-render 與不必要的圖片請求。
- 如需更進一步的量化數據，可使用 React Profiler 或 Performance 面板做前後對比。
