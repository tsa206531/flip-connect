# 0902 解法紀錄（前端壓縮 + Firestore base64 暫行方案）

## 背景與問題
- 後端 `/api/upload` 目前會將兩張圖片轉成 base64 存到同一筆 Firestore 文件（frontImageUrl、backImageUrl）。
- Firestore 「單一文件」大小上限為 1 MiB（約 1,048,576 bytes）。
- 圖片轉成 base64 會膨脹約 4/3（約 1.33 倍）。若兩張原圖各 1.2–1.5MB，轉 base64 後總量會遠超 1 MiB，導致寫入失敗。
- 寫入失敗時 API 在 Step 9 回傳 503，前端顯示「目前無法驗證上傳狀態，請稍後再試」。

## 最終解法（可立即上線）
- 在前端先將每張圖片壓縮到約 250–300KB（JPEG 品質 0.75–0.85、長邊 1200–1600px），再送到現有 `/api/upload`。
- 後端流程不變，仍以 base64 存入 Firestore。兩張圖加上文字欄位，總量將在 1 MiB 以內，避免寫入失敗。
- UI 提示改為「PNG、JPG，限制 350KB」（已修改）。

## 變更內容
- [x] app/upload/page.tsx：上傳區塊提示文字由「限制 1.5MB」改為「限制 350KB」。
- [ ] 在前端送出前加入壓縮邏輯，將原始檔換成壓縮後檔案再 append 進 FormData。

## 實作步驟（前端）

1) 加入壓縮工具函式（可放在 `app/upload/page.tsx` 或 `lib/utils.ts`）

```ts
// 圖片載入（支援所有瀏覽器）
async function loadImage(file: File): Promise<HTMLImageElement> {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(file)
    const img = new Image()
    img.onload = () => {
      URL.revokeObjectURL(url)
      resolve(img)
    }
    img.onerror = (e) => {
      URL.revokeObjectURL(url)
      reject(e)
    }
    img.src = url
  })
}

// 依最大邊長與品質壓縮成 JPEG
async function compressImage(
  file: File,
  maxDim = 1600,
  quality = 0.82
): Promise<File> {
  const img = await loadImage(file)
  const scale = Math.min(1, maxDim / Math.max(img.width, img.height))
  const targetW = Math.round(img.width * scale)
  const targetH = Math.round(img.height * scale)

  const canvas = document.createElement('canvas')
  canvas.width = targetW
  canvas.height = targetH
  const ctx = canvas.getContext('2d')!
  ctx.drawImage(img, 0, 0, targetW, targetH)

  const blob: Blob = await new Promise((resolve, reject) => {
    canvas.toBlob(
      (b) => (b ? resolve(b) : reject(new Error('toBlob failed'))),
      'image/jpeg',
      quality
    )
  })

  const outName = file.name.replace(/\.(png|jpg|jpeg|webp|gif)$/i, '.jpg')
  return new File([blob], outName, { type: 'image/jpeg' })
}

// 嘗試壓到 targetKB 以下（逐步降品質/解析度）
async function compressToTargetKB(
  file: File,
  targetKB = 300,
  startMaxDim = 1600
): Promise<File> {
  let quality = 0.85
  let maxDim = startMaxDim
  let current = file

  for (let i = 0; i < 6; i++) {
    current = await compressImage(current, maxDim, quality)
    const sizeKB = current.size / 1024
    if (sizeKB <= targetKB) break

    if (quality > 0.7) {
      quality -= 0.05
    } else if (maxDim > 1200) {
      maxDim -= 200
    } else {
      break // 已到達我們設定的下限
    }
  }
  return current
}
```

2) 在送出前壓縮並替換檔案（`handleSubmit` 內建立 `FormData` 之前）

```ts
console.log('Compressing images before upload...')
const frontCompressed = await compressToTargetKB(frontImage!, 300, 1600)
const backCompressed = await compressToTargetKB(backImage!, 300, 1600)

console.log('Original sizes:',
  (frontImage!.size / 1024).toFixed(1), 'KB,',
  (backImage!.size / 1024).toFixed(1), 'KB'
)
console.log('Compressed sizes:',
  (frontCompressed.size / 1024).toFixed(1), 'KB,',
  (backCompressed.size / 1024).toFixed(1), 'KB'
)

const formData = new FormData()
formData.append('name', name.trim())
formData.append('position', position.trim())
formData.append('frontImage', frontCompressed) // 用壓縮後檔案
formData.append('backImage', backCompressed)   // 用壓縮後檔案
formData.append('userId', user?.uid || '')
formData.append('userEmail', user?.email || '')
```

3) UI 文案同步（已完成）
- 上傳提示改為「PNG、JPG，限制 350KB」。

4) 可選：調整前端原始檔驗證（若要更一致）
- 目前前端 `handleFile` 最大值為 1.5MB，可改為 350KB，一開始就提醒使用者。由於我們會在送出時自動壓縮，也可以保留 1.5MB，交由壓縮流程處理。

5) 測試與驗證
- 用原始 1.2–1.5MB 的兩張圖片上傳：
  - 應先被壓縮到約 250–300KB/張；
  - `/api/upload` 正常回 200；
  - Firestore 文件建立成功；
  - 前端不再出現「目前無法驗證上傳狀態」。

6) 注意事項
- JPEG 轉檔會移除透明背景（名片一般非透明，影響可忽略）。
- 個別圖片若在 1600px、品質 0.7 的情況下仍超過 300KB，就以當前大小送出（少見）。
- 效能：壓縮在前端執行，對行動裝置會多一些 CPU 負載，但可接受；可視需要增加進度提示。

## 後續優化（可選）
- 若之後可使用 Cloudinary / 其他圖床：改為「物件儲存存圖，Firestore 存 URL」，圖片不再 base64，品質更好、讀取更快。

---

以上為本次上線的暫行解法與實作步驟，確保兩張圖總量不會超過 Firestore 單文件上限，避免上傳失敗。